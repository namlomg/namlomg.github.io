<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Heart Particle Animation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        html, body {
            width: 100%;
            height: 100vh;
            height: -webkit-fill-available;
            overflow: hidden;
            position: fixed;
            background: #0a0a0a;
            touch-action: none;
            overscroll-behavior: none;
        }
        #canvas-container {
            width: 100%;
            height: 100vh;
            height: -webkit-fill-available;
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <script>
        // Phát hiện thiết bị mobile
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        
        // Giảm số lượng particle trên mobile
        const particleCount = isMobile ? 800 : 2000;
        const particleSize = isMobile ? 2.5 : 3;
        const driftStrength = 0.3;
        const loopSpeed = 0.002;
        
        let particles = [];
        let time = 0;
        let pg; // Graphics buffer cho iOS
        
        function setup() {
            // Lấy kích thước thực của viewport trên iOS
            let w = window.innerWidth;
            let h = window.innerHeight;
            
            // Tạo canvas trong container
            let canvas = createCanvas(w, h);
            canvas.parent('canvas-container');
            
            // Tạo graphics buffer nếu là iOS để render mượt hơn
            if (isIOS) {
                pixelDensity(1); // Giảm pixel density trên iOS
            }
            
            // Khởi tạo particles
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }
            
            // Tối ưu rendering
            if (isMobile) {
                noSmooth();
                frameRate(30); // Giảm frame rate trên mobile
            } else {
                frameRate(60);
            }
        }
        
        function draw() {
            // Background với alpha thấp để tạo trail effect nhẹ
            background(10, 10, 15);
            
            // Di chuyển origin về giữa màn hình
            translate(width / 2, height / 2.2);
            let scale = min(width, height) / 35;
            
            time += loopSpeed;
            
            // Update và vẽ particles
            for (let p of particles) {
                p.update();
                p.display(scale);
            }
        }
        
        function windowResized() {
            // Xử lý resize cho iOS
            let w = window.innerWidth;
            let h = window.innerHeight;
            resizeCanvas(w, h);
        }
        
        // Ngăn hành vi mặc định trên iOS
        function touchStarted() {
            return false;
        }
        
        function touchMoved() {
            return false;
        }
        
        // Xử lý orientation change trên iOS
        window.addEventListener('orientationchange', function() {
            setTimeout(function() {
                resizeCanvas(window.innerWidth, window.innerHeight);
            }, 100);
        });
        
        class Particle {
            constructor() {
                this.reset();
            }
            
            reset() {
                // Tạo hình trái tim bằng phương trình tham số
                let t = random(TWO_PI);
                this.baseX = 16 * pow(sin(t), 3);
                this.baseY = -(13 * cos(t) - 5 * cos(2 * t) - 2 * cos(3 * t) - cos(4 * t));
                
                // Thêm nhiễu Gaussian để tạo độ dày
                let offset = randomGaussian(0, 1.5);
                let angle = random(TWO_PI);
                this.baseX += cos(angle) * offset;
                this.baseY += sin(angle) * offset;
                
                // Offset cho Perlin noise
                this.noiseOffsetX = random(1000);
                this.noiseOffsetY = random(1000);
                
                // Thuộc tính fade và fall
                this.life = 1.0;
                this.fadeRate = random(0.001, 0.003);
                this.drift = random(0.5, 1.5);
                this.fallSpeed = random(0.01, 0.05);
                this.fallOffset = 0;
                
                // Màu sắc
                this.hue = random(330, 360); // Đỏ đến hồng
                this.saturation = random(70, 100);
                this.brightness = random(70, 100);
                this.depth = random(0.3, 1.0);
            }
            
            update() {
                // Giảm life và tăng fallOffset
                this.life -= this.fadeRate;
                this.fallOffset += this.fallSpeed * (1 - this.life);
                
                // Reset khi hết life
                if (this.life <= 0) {
                    this.reset();
                }
            }
            
            display(scale) {
                // Thêm drift bằng Perlin noise
                let nx = noise(this.noiseOffsetX + time) - 0.5;
                let ny = noise(this.noiseOffsetY + time) - 0.5;
                
                let x = this.baseX + nx * driftStrength * this.drift;
                let y = this.baseY + ny * driftStrength * this.drift + this.fallOffset;
                
                // Scale lên theo kích thước canvas
                x *= scale;
                y *= scale;
                
                // Tính alpha và size dựa trên life
                let alpha = this.life * this.depth * 255;
                let size = particleSize * this.depth * sqrt(this.life);
                
                colorMode(HSB);
                noStroke();
                
                // Giảm số layer trên mobile để tăng performance
                let blurLayers = isMobile ? 1 : 2;
                for (let i = 0; i < blurLayers; i++) {
                    let s = size * (1 + i * 0.5);
                    let a = alpha * (1 - i * 0.4);
                    fill(this.hue, this.saturation, this.brightness, a * 0.4);
                    ellipse(x, y, s, s);
                }
                
                // Core particle
                fill(this.hue, this.saturation, this.brightness, alpha);
                ellipse(x, y, size * 0.6, size * 0.6);
            }
        }
    </script>
</body>
</html>